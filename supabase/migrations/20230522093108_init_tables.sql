create table "public"."repo" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone default now(),
    "user_id" uuid not null,
    "comment" text,
    "github_id" bigint not null
);


alter table "public"."repo" enable row level security;

create table "public"."repo_tag" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone default now(),
    "tag_id" bigint not null,
    "repo_id" bigint not null,
    "user_id" uuid not null
);


alter table "public"."repo_tag" enable row level security;

create table "public"."tag" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone default now(),
    "user_id" uuid not null,
    "title" text not null
);


alter table "public"."tag" enable row level security;

CREATE UNIQUE INDEX repo_pkey ON public.repo USING btree (id);

CREATE UNIQUE INDEX repo_tag_pkey ON public.repo_tag USING btree (id);

CREATE UNIQUE INDEX tag_pkey ON public.tag USING btree (id);

CREATE UNIQUE INDEX user_repo_index ON public.repo USING btree (user_id, github_id);

CREATE UNIQUE INDEX user_repo_tag_index ON public.repo_tag USING btree (user_id, repo_id, tag_id);

CREATE UNIQUE INDEX user_tag_index ON public.tag USING btree (user_id, title);

alter table "public"."repo" add constraint "repo_pkey" PRIMARY KEY using index "repo_pkey";

alter table "public"."repo_tag" add constraint "repo_tag_pkey" PRIMARY KEY using index "repo_tag_pkey";

alter table "public"."tag" add constraint "tag_pkey" PRIMARY KEY using index "tag_pkey";

alter table "public"."repo" add constraint "repo_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) not valid;

alter table "public"."repo" validate constraint "repo_user_id_fkey";

alter table "public"."repo" add constraint "user_repo_index" UNIQUE using index "user_repo_index";

alter table "public"."repo_tag" add constraint "repo_tag_repo_id_fkey" FOREIGN KEY (repo_id) REFERENCES repo(id) not valid;

alter table "public"."repo_tag" validate constraint "repo_tag_repo_id_fkey";

alter table "public"."repo_tag" add constraint "repo_tag_tag_id_fkey" FOREIGN KEY (tag_id) REFERENCES tag(id) ON DELETE CASCADE not valid;

alter table "public"."repo_tag" validate constraint "repo_tag_tag_id_fkey";

alter table "public"."repo_tag" add constraint "repo_tag_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) not valid;

alter table "public"."repo_tag" validate constraint "repo_tag_user_id_fkey";

alter table "public"."repo_tag" add constraint "user_repo_tag_index" UNIQUE using index "user_repo_tag_index";

alter table "public"."tag" add constraint "tag_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) not valid;

alter table "public"."tag" validate constraint "tag_user_id_fkey";

alter table "public"."tag" add constraint "user_tag_index" UNIQUE using index "user_tag_index";

create policy "Allow authenticated users to insert repo data"
on "public"."repo"
as permissive
for insert
to authenticated
with check (true);


create policy "User can access own repo data"
on "public"."repo"
as permissive
for all
to authenticated
using ((user_id = auth.uid()))
with check ((user_id = auth.uid()));


create policy "Allow authenticated users to insert repo_tag data"
on "public"."repo_tag"
as permissive
for insert
to authenticated
with check (true);


create policy "User can access own repo_tag data"
on "public"."repo_tag"
as permissive
for all
to authenticated
using ((user_id = auth.uid()))
with check ((user_id = auth.uid()));


create policy "Allow authenticated users to insert tag data"
on "public"."tag"
as permissive
for insert
to authenticated
with check (true);


create policy "User can access own tag data"
on "public"."tag"
as permissive
for all
to authenticated
using ((user_id = auth.uid()))
with check ((user_id = auth.uid()));



